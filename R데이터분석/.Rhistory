df2
df1 <- df1[order(df1$id),]
df1
df1 <- data.frame(id=df1$id, group=df1$group)
df1
df2
df_ref <- data.frame(id=seq(1,15,1), group=data$합격여부)
df_ref <- data.frame(id=seq(1,15,1), group=data$합격여부);
df_ref
df_ref$group <- ifelse(df_ref$group=="합격", 1, 0)
df_ref
df1
df_ref
df1
df11 <- data.frame(id=df1$id,
group=ifelse(df1$group==1),1,0)
df11 <- data.frame(id=df1$id,
group=ifelse(df1$group==1),2,0)
df11 <- data.frame(id=df1$id, group=ifelse(df1$group==1,1,0))
df12 <- data.frame(id=df1$id, group=ifelse(df1$group==2,1,0))
df13 <- data.frame(id=df1$id, group=ifelse(df1$group==3,1,0))
confusionMatrix(df11$group, df_ref$group)
df11
df_ref
df_ref$group <- as.factor(df_ref$group)
df11 <- data.frame(id=df1$id, group=ifelse(df1$group==1,1,0)); df11$group <- as.factor(df11$group)
df12 <- data.frame(id=df1$id, group=ifelse(df1$group==2,1,0)); df12$group <- as.factor(df12$group)
df13 <- data.frame(id=df1$id, group=ifelse(df1$group==3,1,0)); df13$group <- as.factor(df13$group)
confusionMatrix(df11$group, df_ref$group)
confusionMatrix(df12$group, df_ref$group)
confusionMatrix(df13$group, df_ref$group)
df21 <- data.frame(id=df2$id, group=ifelse(df2$group==1,1,0)); df21$group <- as.factor(df21$group)
df22 <- data.frame(id=df2$id, group=ifelse(df2$group==2,1,0)); df22$group <- as.factor(df22$group)
df23 <- data.frame(id=df2$id, group=ifelse(df2$group==3,1,0)); df23$group <- as.factor(df23$group)
confusionMatrix(df21$group, df_ref$group)
confusionMatrix(df22$group, df_ref$group)
confusionMatrix(df23$group, df_ref$group)
library(ggplot2)
# 2. ggplot2 diamonds 데이터셋 활용하여 다음의 조건에 맞게 비계층적 군집 수행
data("diamonds")
dia <- diamonds
str(dia)
dia1 <- data.frame(price=dia$price, carat=dia$carat, depth=dia$depth, table=dia$table)
dia1
head(dia1)
head(dia1); str(dia1)
head(dia1)
# - 위 작업 후 1000개의 데이터 랜덤샘플링하여 dia2 생성
table(dia1$price)
# - 위 작업 후 1000개의 데이터 랜덤샘플링하여 dia2 생성
table(dia1$carat)
# - 위 작업 후 1000개의 데이터 랜덤샘플링하여 dia2 생성
table(dia1$depth)
# - 위 작업 후 1000개의 데이터 랜덤샘플링하여 dia2 생성
table(dia1$table)
# - 위 작업 후 1000개의 데이터 랜덤샘플링하여 dia2 생성
idx <- createDataPartition(dia1, times=1000)
# - 위 작업 후 1000개의 데이터 랜덤샘플링하여 dia2 생성
idx <- sample(dia, 1000, replace=T)
dia2 <- dia1[idx,]
idx
# - 위 작업 후 1000개의 데이터 랜덤샘플링하여 dia2 생성
dia2 <- sample(dia1, 1000, replace=T)
dia2
head(dia2)
# - 위 작업 후 1000개의 데이터 랜덤샘플링하여 dia2 생성
dia1
# - 위 작업 후 1000개의 데이터 랜덤샘플링하여 dia2 생성
idx <- sample(1:length(dia1$price), 1000, replace = T)
dia2 <- dia1[idx,]
dim(dia2)
dia2
# - dia2 데이터 정규화 진행
dia2.norm <- scale(dia2)
# - nbclust 이용 적정 k값 산정
nc.kms <- NbClust::NbClust(dia2.norm)
library(NbClust)
# - nbclust 이용 적정 k값 산정
nc.kms <- NbClust::NbClust(dia2.norm)
# - nbclust 이용 적정 k값 산정
nc.kms <- NbClust::NbClust(dia2.norm, method="kmeans")
nc.kms
# - nbclust 이용 적정 k값 산정
nc.kms <- NbClust::NbClust(dia2.norm, method="kmeans")
nc.kms$Best.nc
nc.kms$Best.nc[1,]
table(nc.kms$Best.nc[1,])
# - 비계층적 군집실시
clustering.kms <- kmeans(dia2.norm, 3)
clustering.kms$size
clustering.kms
nc2.kms <- nc.kms
data <- read.csv("data\\interview.csv", stringsAsFactors = F)
head(data)
# - 데이터 첫번째 컬럼 삭제
data <- data[,-1]
# - 와드연결법 사용하여 수행
str(data)
summary(data)
data$합격여부;
d <- dist(data[,-8], method = "euclidean")
clustering.w <- hclust(d, method = "ward.D")
clustering.w
summary(clustering.w)
par(mfrow=c(1,2))
plot(clustering.w)
rect.hclust(clustering.w, k = 3, border = 'red')
# - 3개의 군집으로 덴드로그램 그리기
data.norm <- scale(data[,-8])
clustering.kms <- kmeans(data.norm, 3)
plot(data.norm, col=clustering.kms$cluster)
points(clustering.kms$centers, col=1:3, pch=9, cex=1.5)
# - 군집결과와 실제 데이터의 합격여부와 비교검토
df_ref <- data.frame(id=seq(1,15,1), group=data$합격여부);
df_ref$group <- ifelse(df_ref$group=="합격", 1, 0)
df_ref$group <- as.factor(df_ref$group)
df_ref
clustering.w.cut <- cutree(clustering.w, k=3)
df1 <- data.frame(id=clustering.w$order, group=clustering.w.cut)
df1 <- df1[order(df1$id),]
df1 <- data.frame(id=df1$id, group=df1$group)
df1
df11 <- data.frame(id=df1$id, group=ifelse(df1$group==1,1,0)); df11$group <- as.factor(df11$group)
df12 <- data.frame(id=df1$id, group=ifelse(df1$group==2,1,0)); df12$group <- as.factor(df12$group)
df13 <- data.frame(id=df1$id, group=ifelse(df1$group==3,1,0)); df13$group <- as.factor(df13$group)
confusionMatrix(df11$group, df_ref$group)
confusionMatrix(df12$group, df_ref$group)
confusionMatrix(df13$group, df_ref$group) # Accuracy : 0.7333(Best)
str(clustering.kms)
df2 <- data.frame(id=seq(1,15,1), group=clustering.kms$cluster)
df2
df21 <- data.frame(id=df2$id, group=ifelse(df2$group==1,1,0)); df21$group <- as.factor(df21$group)
df22 <- data.frame(id=df2$id, group=ifelse(df2$group==2,1,0)); df22$group <- as.factor(df22$group)
df23 <- data.frame(id=df2$id, group=ifelse(df2$group==3,1,0)); df23$group <- as.factor(df23$group)
confusionMatrix(df21$group, df_ref$group)
confusionMatrix(df22$group, df_ref$group) # Accuracy : 1(Best)
confusionMatrix(df23$group, df_ref$group)
data("diamonds")
dia <- diamonds
str(dia)
dia1 <- data.frame(price=dia$price, carat=dia$carat, depth=dia$depth, table=dia$table)
head(dia1)
# - 위 작업 후 1000개의 데이터 랜덤샘플링하여 dia2 생성
idx <- sample(1:length(dia1$price), 1000, replace = T)
dia2 <- dia1[idx,]
# - dia2 데이터 정규화 진행
dia2.norm <- scale(dia2)
table(nc2.kms$Best.nc[1,]) # 3
# - 비계층적 군집실시
clustering2.kms <- kmeans(dia2.norm, 3)
clustering2.kms
str(clustering2.kms)
# - carat과 price에 대한 산포도 작성(plot() 의 컬러 인수에 군집결과$cluster를 할당하여 군집별 색상 구분)
plot(dia2.norm, col=clustering2.kms$cluster)
# - carat과 price에 대한 산포도 작성(plot() 의 컬러 인수에 군집결과$cluster를 할당하여 군집별 색상 구분)
plot(x=dia2.norm$carat, y=dia2.norm$price, col=clustering2.kms$cluster)
# - carat과 price에 대한 산포도 작성(plot() 의 컬러 인수에 군집결과$cluster를 할당하여 군집별 색상 구분)
plot(dia2.norm, col=clustering2.kms$cluster)
points(cluster.kms$centers, col=1:3, pch=8, cex=1.5)
points(clustering2.kms$centers, col=1:3, pch=8, cex=1.5)
points(clustering2.kms$centers, col=1:3, pch=9, cex=1.5)
# - carat과 price에 대한 산포도 작성(plot() 의 컬러 인수에 군집결과$cluster를 할당하여 군집별 색상 구분)
plot(dia2.norm, col=clustering2.kms$cluster)
?plot
# - carat과 price에 대한 산포도 작성(plot() 의 컬러 인수에 군집결과$cluster를 할당하여 군집별 색상 구분)
plot(dia2.norm, col=clustering2.kms$cluster, pch=clustering2.kms$cluster)
# - carat과 price에 대한 산포도 작성(plot() 의 컬러 인수에 군집결과$cluster를 할당하여 군집별 색상 구분)
plot(dia2.norm, col=clustering2.kms$cluster, pch=c(1,2,3))
# - carat과 price에 대한 산포도 작성(plot() 의 컬러 인수에 군집결과$cluster를 할당하여 군집별 색상 구분)
plot(dia2.norm, col=clustering2.kms$cluster, pch=c(1,2,4))
# - carat과 price에 대한 산포도 작성(plot() 의 컬러 인수에 군집결과$cluster를 할당하여 군집별 색상 구분)
plot(dia2.norm, col=clustering2.kms$cluster, pch=c(1,2,5))
# - carat과 price에 대한 산포도 작성(plot() 의 컬러 인수에 군집결과$cluster를 할당하여 군집별 색상 구분)
plot(dia2.norm, col=clustering2.kms$cluster, pch=clustering2.kms$cluster)
Package_Data_List <- data(package = .packages(all.available = TRUE))
Package_Data_List
library(cluster)
library(caret)
library(ggplot2)
library(NbClust)
# 1. interview.csv 파일을 활용하여 계층적 군집을 다음의 조건에 맞게 수행해보세요
data <- read.csv("data\\interview.csv", stringsAsFactors = F)
head(data)
# - 데이터 첫번째 컬럼 삭제
data <- data[,-1]
# - 와드연결법 사용하여 수행
str(data)
summary(data)
data$합격여부;
d <- dist(data[,-8], method = "euclidean")
clustering.w <- hclust(d, method = "ward.D")
clustering.w
summary(clustering.w)
par(mfrow=c(1,2))
plot(clustering.w)
rect.hclust(clustering.w, k = 3, border = 'red')
par(mfrow=c(1,2))
plot(clustering.w, hang=-1)
rect.hclust(clustering.w, k = 3, border = 'red')
# - 3개의 군집으로 덴드로그램 그리기
data.norm <- scale(data[,-8])
clustering.kms <- kmeans(data.norm, 3)
plot(data.norm, col=clustering.kms$cluster)
points(clustering.kms$centers, col=1:3, pch=9, cex=1.5)
par(mfrow=c(1,2))
plot(clustering.w, hang=-1)
rect.hclust(clustering.w, k = 3, border = 'red')
# - 3개의 군집으로 덴드로그램 그리기
data.norm <- scale(data[,-8])
clustering.kms <- kmeans(data.norm, 3)
plot(data.norm, col=clustering.kms$cluster, pch=clustering.kms$cluster)
points(clustering.kms$centers, col=1:3, pch=9, cex=1.5)
par(mfrow=c(1,2))
plot(clustering.w, hang=-1)
rect.hclust(clustering.w, k = 3, border = 'red')
# - 3개의 군집으로 덴드로그램 그리기
data.norm <- scale(data[,-8])
clustering.kms <- kmeans(data.norm, 3)
plot(data.norm, col=clustering.kms$cluster, pch=clustering.kms$cluster)
points(clustering.kms$centers, col=1:3, pch=8, cex=1.5)
df_ref <- data.frame(id=seq(1,15,1), group=data$합격여부);
df_ref$group <- ifelse(df_ref$group=="합격", 1, 0)
df_ref$group <- as.factor(df_ref$group)
df_ref
clustering.w.cut <- cutree(clustering.w, k=3)
df1 <- data.frame(id=clustering.w$order, group=clustering.w.cut)
df1 <- df1[order(df1$id),]
df1 <- data.frame(id=df1$id, group=df1$group)
df1
df11 <- data.frame(id=df1$id, group=ifelse(df1$group==1,1,0)); df11$group <- as.factor(df11$group)
df12 <- data.frame(id=df1$id, group=ifelse(df1$group==2,1,0)); df12$group <- as.factor(df12$group)
df13 <- data.frame(id=df1$id, group=ifelse(df1$group==3,1,0)); df13$group <- as.factor(df13$group)
text(data.norm)
text(data.norm, pos=3)
par(mfrow=c(1,2))
plot(clustering.w, hang=-1)
rect.hclust(clustering.w, k = 3, border = 'red')
# - 3개의 군집으로 덴드로그램 그리기
data.norm <- scale(data[,-8])
clustering.kms <- kmeans(data.norm, 3)
plot(data.norm, col=clustering.kms$cluster, pch=clustering.kms$cluster)
text(data.norm, pos=3)
points(clustering.kms$centers, col=1:3, pch=8, cex=1.5)
par(mfrow=c(1,2))
plot(clustering.w, hang=-1)
rect.hclust(clustering.w, k = 3, border = 'red')
# - 3개의 군집으로 덴드로그램 그리기
data.norm <- scale(data[,-8])
clustering.kms <- kmeans(data.norm, 3)
plot(data.norm, col=clustering.kms$cluster, pch=clustering.kms$cluster)
text(data.norm, pos=3)
par(mfrow=c(1,2))
plot(clustering.w, hang=-1)
rect.hclust(clustering.w, k = 3, border = 'red')
# - 3개의 군집으로 덴드로그램 그리기
data.norm <- scale(data[,-8])
clustering.kms <- kmeans(data.norm, 3)
plot(data.norm, col=clustering.kms$cluster)
text(data.norm, pos=3)
# points(clustering.kms$centers, col=1:3, pch=8, cex=1.5)
data("diamonds")
dia <- diamonds
# - price, carat, depth, table 4개의 컬럼 추출하여 dia1 생성
str(dia)
dia1 <- data.frame(price=dia$price, carat=dia$carat, depth=dia$depth, table=dia$table)
head(dia1)
# - 위 작업 후 1000개의 데이터 랜덤샘플링하여 dia2 생성
idx <- sample(1:length(dia1$price), 1000, replace = T)
dia2 <- dia1[idx,]
# - dia2 데이터 정규화 진행
dia2.norm <- scale(dia2)
# - nbclust 이용 적정 k값 산정
nc2.kms <- NbClust::NbClust(dia2.norm, method="kmeans")
table(nc2.kms$Best.nc[1,]) # 3
# - 비계층적 군집실시
clustering2.kms <- kmeans(dia2.norm, 3)
str(clustering2.kms)
# - carat과 price에 대한 산포도 작성(plot() 의 컬러 인수에 군집결과$cluster를 할당하여 군집별 색상 구분)
plot(dia2.norm, col=clustering2.kms$cluster, pch=clustering2.kms$cluster)
install.packages("arules")
library(arules)
install.packages("arulesViz")
library(arulesViz)
knitr::opts_chunk$set(echo = TRUE)
# 1. file load: transaction 객체 생성
transac <- arules::read.transactions("..\\..\\..\\data\\tran.txt",
format="basket", sep=",")
transac
# 1. file load: transaction 객체 생성
transac <- arules::read.transactions("..\\..\\..\\data\\tran.txt",
format="basket", sep=",")
transac
# 2. transaction 데이터 보기: inspect()
inspect(transac)
inspect(transac)
?inspect
?inspect
# 3. 규칙 조사: apriori()
insight <- arules::apriori(transac, parameter=list(supp=0.3, cof=0.1))
# 3. 규칙 조사: apriori()
insight <- arules::apriori(transac, parameter=list(supp=0.3, conf=0.1))
inspect(insight)
inspect(insight)
inspect(insight)
inspect(insight)
# 6. plot
plot(insight, method="grouped")
par(mfrow=c(1,2))
plot(insight, method="grouped")
plot(insight, method="graph", control = list(type="items"))
# 6. plot
plot(insight, method="grouped")
plot(insight, method="graph", control = list(type="items"))
# 6. plot
plot(insight, method="grouped")
plot(insight, method="graph")#, control = list(type="items"))
plot(insight, method="graph", control = list(type="items"))
plot(insight, method="graph", control = list(type="items"))
plot(insight, method="graph")#, control = list(type="items"))
par(mfrow=c(1,2))
plot(insight, method="grouped")
plot(insight, method="graph")#, control = list(type="items"))
plot(insight, method="graph")#, control = list(type="items"))
# Groceries 데이터셋
data("Groceries")
str(Groceries)
head(Groceries)
Groceries
?Groceries
# Groceries 데이터셋
data(arules::Groceries)
# Groceries 데이터셋
data(Groceries)
str(Groceries)
str(Groceries)
Groceries
# data.frame으로 변환
Groceries.df <- as(Groceries, "data.frame")
head(Groceries.df)
head(Groceries.df)
head(Groceries.df)
# 지지도 0.001, 신뢰도 0.8 이상을 만족하는 규칙 찾기
rules <- apriori(Groceries, parameter=list(supp=0.001, conf=0.8))
# 규칙을 구성하는 lhs -> rhs의 item 빈도 수 보기
plot(rules, method="grouped")
# conf 기준 내림차순으로 규칙 정렬
rules <- sort(rules, decreasing=T, by="Confidence")
inspect(rules)
# conf 기준 내림차순으로 규칙 정렬
rules <- sort(rules, decreasing=T, by="Confidence")
# conf 기준 내림차순으로 규칙 정렬
rules <- arules::sort(rules, decreasing=T, by="Confidence")
# conf 기준 내림차순으로 규칙 정렬
rules <- arules::sort(rules, decreasing=T, by="confidence")
inspect(rules)
inspect(head(rules,10))
inspect(head(rules,10))
# lift 기준
rules1 <- arules::sort(rules, decreasing=T, by="lift")
inspect(rules1)
inspect(head(rules1,10))
# conf 기준 내림차순으로 규칙 정렬
rules <- arules::sort(rules, decreasing=T, by="confidence")
inspect(rules)
inspect(head(rules,10))
inspect(head(rules1,10))
inspect(head(rules,10))
inspect(head(rules1,10))
# 발견된 규칙 시각화
plot(rules, method="graph")
# 특정 상품 subset과 시각화
# 오른쪽 item이 전지분유(whole milk)인 규칙만 subset으로 작성
wmilk <- subset(rules, rhs %in% 'whole milk')
wmilk
inspect(wmilk)
inspect(head(wmilk,10))
plot(wmilk, method="graph")
# 오른쪽 item이 other vegetables인 규칙만 서브 셋으로 작성
oveg <- subset(rules, rhs %in% 'other vegetables')
oveg
inspect(oveg)
inspect(head(oveg))
# 오른쪽 item이 vegetables 단어가 포함된 규칙만 서브 셋으로 작성
oveg <- subset(rules, rhs %pin% 'vegetables')
# 오른쪽 item이 vegetables 단어가 포함된 규칙만 서브 셋으로 작성
oveg1 <- subset(rules, rhs %pin% 'vegetables')
oveg1
inspect(head(oveg1))
inspect(oveg1)
# 오른쪽 item이 other vegetables인 규칙만 서브 셋으로 작성
oveg <- subset(rules, rhs %in% 'other vegetables')
oveg
inspect(head(oveg))
inspect(oveg1)
# 왼쪽 item이 butter 또는 yogurt인 규칙만 서브셋으로 작성
butter_yogurt <- subset(rules, lhs %in% c('butter', 'yogurt'))
butter_yogurt
inspect(butter_yogurt)
plot(butter_yogurt, method="graph")
butter_yogurt1 <- subset(butter_yogurt, confidence>=0.9 & lift>=5)
inspect(head(butter_yogurt1))
plot(butter_yogurt1, method="graph")
# cf) 세부 거래품목 빈도확인 itemFrequency
sort(arules::itemFrequency(Groceries, type="absolute"), decreasing=T)
arules::itemFrequencyPlot(Groceries, topN=10, type="absolute")
groc <- apriori(Groceries, parameter=list(supp=0.005, conf=0.5, minlen=2))
inspect(groc)
# cf) 세부 거래품목 빈도확인 itemFrequency
sort(arules::itemFrequency(Groceries, type="absolute"), decreasing=T)
arules::itemFrequencyPlot(Groceries, topN=10, type="absolute")
inspect(groc)
arules::itemFrequencyPlot(Groceries, topN=10, type="relative")
arules::itemFrequencyPlot(Groceries, topN=10, type="absolute")
arules::itemFrequencyPlot(Groceries, topN=10, type="relative")
# cf) 세부 거래품목 빈도확인 itemFrequency
sort(arules::itemFrequency(Groceries, type="absolute"), decreasing=T)
arules::itemFrequencyPlot(Groceries, topN=10, type="absolute")
arules::itemFrequencyPlot(Groceries, topN=10, type="relative")
# 1.Adult 데이터셋을 로드하세요
data("Adult")
?Adult
library(arules)
library(arluesViz)
library(arluesVis)
library(arules)
library(arulesViz)
library(dplyr)
# 1.Adult 데이터셋을 로드하세요
data("Adult")
adult <- Adult
?apriori
# 2. support 0.5 confidence 0.9로 연관규칙 생성
rules <- apriori(adult, parameter=list(supp=0.5, conf=0.9))
inspect(head(rules,10))
rules; inspect(head(rules,10))
# 3. lift 기준 정렬하여 상위 10개 규칙 확인
rules_lift <- sort(rules, decreasing = T, by="lift")
rules_lift
rules_lift; inspect(head(rules_lift,10))
# 4. 위 결과를 연관어 네트워크 시각화
plot(rules_lift)
# 4. 위 결과를 연관어 네트워크 시각화
plot(rules_lift, method="grouped")
# 4. 위 결과를 연관어 네트워크 시각화
plot(rules_lift, method="graph")
# 4. 위 결과를 연관어 네트워크 시각화
plot(rules_lift, method="graph")
# 5. 3의 결과를 LHS와 RHS의 빈도수 시각화 표현
plot(rules_lift, method="grouped")
# 3. 트랜잭션 확인
inspect(head(itms.tr,10))
# 1. 데이터 생성
itms <- list(c("삼겹살","생수",'소주','과자'),
c("삼겹살","생수",'소주','사과'),
c("장어","생수",'소주','양파'),
c("땅콩","생수",'맥주','오이'),
c("땅콩","생수",'맥주','김'))
# 2. 트랜잭션 변환
itms.tr <- as(itms, 'transactions')
# 3. 트랜잭션 확인
inspect(head(itms.tr,10))
# 3. 트랜잭션 확인
inspect(itms.tr)
# 4. 지지도 0.1, 신뢰도 0.8 이상인 연관성 규칙 구하기
rules.itms <- apriori(itms.tr, parameter=list(supp=0.1, conf=0.8))
# 5. 결과 검토
# 1) 도출된 규칙 5개 확인
rules.itms; inspect(rules.itms)
# 2) 향상도가 1.2이상인 규치만 선택하여 내림차순 정렬 보기
rules.itms_lift <- subset(rules.itms, lift>=1.2)
# 2) 향상도가 1.2이상인 규치만 선택하여 내림차순 정렬 보기
rules.itms_lift <- subset(rules.itms, lift>=1.2)
rules.itms_lift <- sort(rules.itms_lift, decreasing=T, by="lift")
inspect(rules.itms_lift)
# 1) 도출된 규칙 5개 확인
rules.itms; inspect(rules.itms)
# 1) 도출된 규칙 5개 확인
rules.itms; inspect(head(rules.itms,5))
# 3) lhs에 삼겹살이 포함된 연관성 규칙
rules.itms_gogi <- subset(rules.itms_lift, lhs %pin% c('삼겹살', '삼겹살'))
# 3) lhs에 삼겹살이 포함된 연관성 규칙
rules.itms_gogi <- subset(rules.itms_lift, lhs %pin% c('삼겹살'))
inspect(rules.itms_gogi)
# 4) lhs에 삼겹살과 과자 동시에 포함하는 규칙(%ain%)
rules.itms_gogiNbisket <- subset(rules.itms_lift, lhs %ain% c('삼겹살', '과자'))
inspect(rules.itms_gogiNbisket)
# 5) lhs에 삼겹살 또는 과자 또는 삼겹살&과자 동시 포함 하는 규칙(%oin%)
rules.itms_gogiNbisket2 <- subset(rules.itms_lift, lhs %oin% c('삼겹살', '과자'))
inspect(rules.itms_gogiNbisket2)
# 1) 도출된 규칙 5개 확인
it.rules; inspect(head(it.rules,5))
# 4. 지지도 0.1, 신뢰도 0.8 이상인 연관성 규칙 구하기
it.rules <- apriori(itms.tr, parameter=list(supp=0.1, conf=0.8))
# 1) 도출된 규칙 5개 확인
it.rules; inspect(head(it.rules,5))
# 2) 향상도가 1.2이상인 규치만 선택하여 내림차순 정렬 보기
it.rules_lift <- subset(it.rules, lift>=1.2)
it.rules_lift <- sort(it.rules_lift, decreasing=T, by="lift")
inspect(it.rules_lift)
# 3) lhs에 삼겹살이 포함된 연관성 규칙
it.rules_gogi <- subset(it.rules, lhs %pin% '삼겹살')
inspect(it.rules_gogi)
# 4) lhs에 삼겹살과 과자 동시에 포함하는 규칙(%ain%)
it.rules_gogiNbisket <- subset(it.rules, lhs %ain% c('삼겹살', '과자'))
inspect(it.rules_gogiNbisket)
# 5) lhs에 삼겹살 또는 과자 또는 삼겹살&과자 동시 포함 하는 규칙(%oin%)
it.rules_gogiNbisket2 <- subset(it.rules, lhs %oin% c('삼겹살', '과자'))
inspect(it.rules_gogiNbisket2)
# 6) it.rules에 대해 지지도 0.2 이상인 항목의 빈도수 그래프 그리기
it.rules_supp <- subset(it.rules, support>=0.2)
inspect(it.rules_supp)
plot(it.rules_supp, ,method="grouped")
